<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Label Tycoon</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base styles */
        body { font-family: 'Inter', sans-serif; background-color: #111827; color: #e5e7eb; }
        .btn { padding: 0.6rem 1.2rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease, opacity 0.2s ease; border: none; text-align: center; display: inline-block; margin: 0.25rem; white-space: nowrap; }
        .btn-primary { background-color: #4f46e5; color: white; } .btn-primary:hover:not(:disabled) { background-color: #4338ca; transform: scale(1.03); }
        .btn-secondary { background-color: #6b7280; color: white; } .btn-secondary:hover:not(:disabled) { background-color: #4b5563; transform: scale(1.03); }
        .btn-success { background-color: #10b981; color: white; } .btn-success:hover:not(:disabled) { background-color: #059669; transform: scale(1.03); }
        .btn-danger { background-color: #ef4444; color: white; } .btn-danger:hover:not(:disabled) { background-color: #dc2626; transform: scale(1.03); }
        .btn-warning { background-color: #f59e0b; color: #1f2937; } .btn-warning:hover:not(:disabled) { background-color: #d97706; transform: scale(1.03); }
        .btn-info { background-color: #3b82f6; color: white; } .btn-info:hover:not(:disabled) { background-color: #2563eb; transform: scale(1.03); }
        .btn-purple { background-color: #8b5cf6; color: white; } .btn-purple:hover:not(:disabled) { background-color: #7c3aed; transform: scale(1.03); }
        .btn-nav { background-color: #374151; color: #d1d5db; } .btn-nav:hover:not(:disabled) { background-color: #4b5563; }
        .btn-nav.active { background-color: #4f46e5; color: white; }


        .btn-disabled { opacity: 0.5; cursor: not-allowed !important; transform: scale(1) !important; }
        .game-container, .start-menu-container { max-width: 1600px; margin: 2rem auto; padding: 1.5rem; background-color: #1f2937; border-radius: 1rem; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4); }
        .start-menu-container { max-width: 600px; text-align: center; }
        .hidden { display: none !important; }
        .game-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 0.5rem; }
        #label-name-display { font-size: 1.5rem; color: #a5b4fc; font-weight: bold; margin-right: 1rem; flex-grow: 1; text-align: center; min-width: 200px; }
        @media (min-width: 640px) { #label-name-display { text-align: left; } }
        #save-game-btn { flex-shrink: 0; }

        .main-nav { display: flex; justify-content: center; gap: 0.5rem; margin-bottom: 1.5rem; }

        .card { background-color: #374151; border-radius: 0.75rem; padding: 1rem; margin-bottom: 1rem; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out; }
        .card:hover { transform: translateY(-4px); box-shadow: 0 8px 15px rgba(0,0,0,0.35); }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; }
        .stat-item { background-color: #374151; padding: 0.75rem; border-radius: 0.5rem; text-align: center; }
        .stat-label { font-size: 0.8rem; color: #9ca3af; margin-bottom: 0.25rem; text-transform: uppercase; }
        .stat-value { font-size: 1.2rem; font-weight: 700; }
        #message-box { margin-top: 1rem; padding: 0.75rem; border-radius: 0.5rem; background-color: #374151; color: #e5e7eb; min-height: 40px; text-align: center; font-style: italic; transition: background-color 0.3s ease, border-color 0.3s ease; }
        .content-grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 1.5rem; }
        .artists-available-col { grid-column: span 12 / span 12; }
        .artists-signed-col { grid-column: span 12 / span 12; }
        .charts-col { grid-column: span 12 / span 12; }
        @media (min-width: 1024px) { .artists-available-col, .artists-signed-col, .charts-col { grid-column: span 4 / span 4; } }
        @media (min-width: 768px) and (max-width: 1023px) { .artists-available-col, .artists-signed-col { grid-column: span 6 / span 6; } .charts-col { grid-column: span 12 / span 12; } }
        .section-container { max-h-[40rem]; overflow-y: auto; padding: 0.75rem; background-color: #111827; border-radius: 0.5rem; box-shadow: inset 0 2px 4px rgba(0,0,0,0.3); }
        .chart-item { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0.75rem; background-color: #4b5563; border-radius: 0.375rem; margin-bottom: 0.5rem; }
        .chart-item:nth-child(odd) { background-color: #525c6b; }
        .chart-rank { font-weight: bold; margin-right: 0.75rem; color: #fbbf24; min-width: 25px; text-align: right; }
        .chart-details { flex-grow: 1; min-width: 0; }
        .chart-title { font-style: italic; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .chart-artist { font-size: 0.85em; color: #d1d5db; }
        .chart-label { font-size: 0.75em; color: #818cf8; margin-left: 0.25rem; font-style: italic;}
        .chart-stats { font-size: 0.8em; color: #9ca3af; text-align: right; min-width: 100px; }
        .modal-backdrop { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.75); display: flex; justify-content: center; align-items: center; z-index: 50; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        .modal-backdrop.active { opacity: 1; visibility: visible; }
        .modal-content { background-color: #1f2937; padding: 2rem; border-radius: 1rem; box-shadow: 0 10px 30px rgba(0,0,0,0.5); width: 90%; max-width: 600px; border: 1px solid #4b5563; transform: scale(0.95); transition: transform 0.3s ease; max-height: 90vh; overflow-y: auto; }
        .modal-backdrop.active .modal-content { transform: scale(1); }
        .modal-title { font-size: 1.5rem; font-weight: bold; color: #a5b4fc; margin-bottom: 1rem; }
        .modal-body p { margin-bottom: 0.75rem; color: #d1d5db; }
        .modal-body label { display: block; margin-bottom: 0.5rem; font-weight: 500; color: #9ca3af; }
        .modal-body select, .modal-body input[type="text"], .modal-body input[type="number"], .modal-body input[type="range"] { width: 100%; padding: 0.5rem; border-radius: 0.375rem; background-color: #374151; border: 1px solid #4b5563; color: #e5e7eb; margin-bottom: 1rem; }
        .modal-body input[type="range"] { padding: 0; }
        .modal-footer { margin-top: 1.5rem; display: flex; justify-content: flex-end; flex-wrap: wrap; gap: 0.5rem; }
        .modal-footer .btn { flex-grow: 1; }
        @media (min-width: 400px) { .modal-footer .btn { flex-grow: 0; } }
        [data-tooltip] { position: relative; cursor: help; }
        [data-tooltip]::after { content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%) translateY(-5px); background-color: #111827; color: #e5e7eb; padding: 0.3rem 0.6rem; border-radius: 0.25rem; font-size: 0.75rem; white-space: nowrap; z-index: 10; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; pointer-events: none; border: 1px solid #4b5563; }
        [data-tooltip]:hover::after { opacity: 1; visibility: visible; }
        .release-history { margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px dashed #4b5563; }
        .release-item { font-size: 0.8rem; color: #9ca3af; margin-bottom: 0.25rem; display: flex; justify-content: space-between; }
        .release-item span:first-child { font-style: italic; color: #d1d5db; max-width: 60%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
        .release-item span:last-child { color: #7dd3fc; }
        .start-menu-input { width: 80%; padding: 0.75rem; border-radius: 0.5rem; background-color: #374151; border: 1px solid #4b5563; color: #e5e7eb; margin: 1rem auto; display: block; text-align: center; font-size: 1.1rem;}
        .artist-status { font-size: 0.8rem; font-weight: bold; color: #facc15; margin-left: 0.5rem; }
        .artist-mood-bar { width: 100%; background-color: #4b5563; border-radius: 0.25rem; height: 0.5rem; overflow: hidden; margin-top: 0.25rem; margin-bottom: 0.25rem; }
        .artist-mood-fill { height: 100%; border-radius: 0.25rem; transition: width 0.3s ease, background-color 0.3s ease; }
        .negotiation-term { margin-bottom: 1rem; }
        .negotiation-term label { font-weight: 600; color: #cbd5e1; }
        .negotiation-term .term-values { display: flex; justify-content: space-between; align-items: center; margin-top: 0.25rem; font-size: 0.9em;}
        .negotiation-term .term-values span { color: #9ca3af; }
        .negotiation-term input[type="range"], .negotiation-term select { margin-top: 0.25rem; }
        .negotiation-feedback { margin-top: 1rem; padding: 0.75rem; border-radius: 0.375rem; background-color: #4b5563; color: #e0e0e0; font-style: italic; }
        #artists-view-container { padding: 1rem; }
        .artist-filters { display: flex; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap; }
        .artist-filters select { padding: 0.5rem; border-radius: 0.375rem; background-color: #374151; border: 1px solid #4b5563; color: #e5e7eb; }
        .global-artist-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 1rem; }
        .global-artist-card { background-color: #272f3a; border: 1px solid #4b5563; }
        .global-artist-card .artist-label { font-size: 0.8rem; color: #a5b4fc; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="start-menu" class="start-menu-container"> <h1 class="text-4xl font-bold text-indigo-400 mb-6">Music Label Tycoon</h1> <p class="text-lg mb-4 text-gray-300">Enter your label name:</p> <input type="text" id="label-name-input" class="start-menu-input" placeholder="E.g., Stellar Records" maxlength="30"> <div class="mt-6 space-x-4"> <button id="new-game-btn" class="btn btn-success text-lg px-6 py-2">Start New Label</button> <button id="load-game-btn" class="btn btn-primary text-lg px-6 py-2">Load Saved Game</button> </div> <p id="start-menu-message" class="mt-4 text-sm text-red-400"></p> </div>

    <div id="game-container" class="game-container hidden">
        <header class="game-header"> <h1 id="label-name-display">Your Label</h1> <button id="save-game-btn" class="btn btn-info" title="Save Game Progress">Save Game</button> </header>
        <nav class="main-nav"> <button id="nav-label-view-btn" class="btn btn-nav active" data-view="label-view">Label HQ</button> <button id="nav-artists-view-btn" class="btn btn-nav" data-view="artists-view-container">Browse Artists</button> </nav>

        <div id="label-view"> <div class="stats-grid mb-8"> <div class="stat-item"><div class="stat-label">Money</div><div id="money" class="stat-value">$0</div></div> <div class="stat-item"><div class="stat-label">Reputation</div><div id="reputation" class="stat-value">0</div></div> <div class="stat-item"><div class="stat-label">Week</div><div id="week" class="stat-value">0</div></div> <div class="stat-item"><div class="stat-label">Artists</div><div id="artist-count" class="stat-value">0</div></div> </div>
            <div id="message-box" class="mb-6">Game messages will appear here.</div>
            <div class="text-center mb-8"> <button id="next-week-btn" class="btn btn-primary text-lg px-8 py-3">Advance to Next Week</button> </div>
            <div class="content-grid"> <div class="artists-available-col"> <h2 class="text-2xl font-semibold mb-4 text-indigo-300">Available Artists</h2> <div id="available-artists" class="section-container space-y-4"></div> </div> <div class="artists-signed-col"> <h2 class="text-2xl font-semibold mb-4 text-emerald-300">Signed Artists</h2> <div id="signed-artists" class="section-container space-y-4"></div> </div> <div class="charts-col space-y-6"> <div> <h2 class="text-2xl font-semibold mb-4 text-amber-300">Top Singles Chart</h2> <div id="song-chart" class="section-container"></div> </div> <div> <h2 class="text-2xl font-semibold mb-4 text-cyan-300">Top Albums Chart</h2> <div id="album-chart" class="section-container"></div> </div> </div> </div>
        </div>

        <div id="artists-view-container" class="hidden">
            <h2 class="text-3xl font-bold text-center mb-6 text-purple-400">Global Artist Roster</h2>
            <div class="artist-filters">
                <div> <label for="filter-artist-status" class="text-sm text-gray-400 mr-2">Status:</label> <select id="filter-artist-status"> <option value="all">All</option> <option value="player">Player Signed</option> <option value="ai_signed">AI Signed</option> <option value="unsigned">Unsigned</option> </select> </div>
                <div> <label for="filter-artist-genre" class="text-sm text-gray-400 mr-2">Genre:</label> <select id="filter-artist-genre"> <option value="all">All Genres</option> </select> </div>
            </div>
            <div id="global-artist-list" class="global-artist-grid section-container"></div>
        </div>
    </div>

    <div id="release-modal" class="modal-backdrop"> <div class="modal-content"> <h3 id="modal-title" class="modal-title">Release Planning</h3> <div id="modal-body" class="modal-body"> <p id="modal-artist-info"></p> <p id="modal-release-type"></p> <div> <label for="release-name-input">Title:</label> <input type="text" id="release-name-input" placeholder="Enter title..." maxlength="50"> </div> <div> <label for="release-format-select">Release Format:</label> <select id="release-format-select"></select> <p id="release-format-description" class="text-xs text-gray-400 italic mt-1">Select a format.</p> </div> <p>Base Production Cost (Pre-Format): <span id="modal-base-cost"></span></p> <div> <label for="marketing-level">Marketing Campaign:</label> <select id="marketing-level"></select> <p class="text-xs text-gray-400 italic">Higher marketing increases initial impact but costs more.</p> </div> <p class="mt-4 font-semibold">Estimated Total Cost: <span id="modal-total-cost"></span></p> </div> <div class="modal-footer"> <button id="modal-cancel-btn" class="btn btn-secondary">Cancel</button> <button id="modal-confirm-btn" class="btn btn-success">Confirm Release</button> </div> </div> </div>

    <div id="contract-negotiation-modal" class="modal-backdrop"> <div class="modal-content"> <h3 id="contract-modal-title" class="modal-title">Contract Negotiation</h3> <div id="contract-modal-body" class="modal-body"> <p id="contract-artist-name" class="text-lg font-semibold mb-2"></p> <p id="contract-artist-stats" class="text-sm text-gray-400 mb-4"></p> <div class="grid grid-cols-1 md:grid-cols-2 gap-4"> <div class="negotiation-term"> <label for="negotiate-advance">Advance Payment ($)</label> <div class="term-values"> <span>Artist Wants: <span id="artist-demand-advance"></span></span> <span>Your Offer: <span id="player-offer-advance-value"></span></span> </div> <input type="range" id="negotiate-advance" min="0" max="100000" step="1000"> </div> <div class="negotiation-term"> <label for="negotiate-royalty">Royalty Rate (%)</label> <div class="term-values"> <span>Artist Wants: <span id="artist-demand-royalty"></span>%</span> <span>Your Offer: <span id="player-offer-royalty-value"></span>%</span> </div> <input type="range" id="negotiate-royalty" min="5" max="50" step="1"> </div> <div class="negotiation-term"> <label for="negotiate-albums">Album Commitment</label> <div class="term-values"> <span>Artist Wants: <span id="artist-demand-albums"></span></span> <span>Your Offer: <span id="player-offer-albums-value"></span></span> </div> <input type="range" id="negotiate-albums" min="1" max="5" step="1"> </div> <div class="negotiation-term"> <label for="negotiate-creative-control">Creative Control</label> <div class="term-values"> <span>Artist Wants: <span id="artist-demand-creative-control"></span></span></div> <select id="negotiate-creative-control"> <option value="label">Label Controlled</option> <option value="collaborative">Collaborative</option> <option value="artist">Artist Controlled</option> </select> </div> <div class="negotiation-term"> <label for="negotiate-tour-support">Touring Support</label> <div class="term-values"><span>Artist Wants: <span id="artist-demand-tour-support"></span></span></div> <select id="negotiate-tour-support"> <option value="none">None</option> <option value="basic">Basic</option> <option value="full">Full</option> </select> </div> <div class="negotiation-term"> <label for="negotiate-merch-split">Merchandise Split (Label/Artist)</label> <div class="term-values"><span>Artist Wants: <span id="artist-demand-merch-split"></span></span></div> <select id="negotiate-merch-split"> <option value="70/30">70% / 30%</option> <option value="50/50">50% / 50%</option> <option value="30/70">30% / 70%</option> </select> </div> </div> <p class="text-xs text-gray-400 mt-2">Note: Option/Termination clauses standard for now.</p> <div id="negotiation-feedback" class="negotiation-feedback hidden"></div> <p class="mt-2 text-sm">Negotiation Round: <span id="negotiation-round">1</span> / <span id="negotiation-max-rounds">3</span></p> </div> <div class="modal-footer"> <button id="contract-walk-away-btn" class="btn btn-danger">Walk Away</button> <button id="contract-accept-artist-btn" class="btn btn-secondary">Accept Artist's Terms</button> <button id="contract-make-offer-btn" class="btn btn-success">Make Offer</button> </div> </div> </div>

    <script>
        // --- Game State ---
        let gameState = null;
        const SAVE_KEY = 'musicTycoonSaveData_v7_contracts';

        // --- Constants ---
        const FIRST_NAMES = ["Alex", "Jamie", "Morgan", "Riley", "Casey", "Skyler", "Jordan", "Taylor", "Kai", "Avery", "Blake", "Drew", "Jesse", "Quinn", "Rowan", "Sage", "Devon", "Emerson", "Finley", "Dakota", "Remy", "Indigo", "Phoenix", "River", "Shiloh", "Nico", "Luca", "Ezra", "Asher", "Silas", "Jasper", "Milo", "Theo", "Leo", "Felix", "Caleb", "Liam", "Noah", "Owen", "Ethan", "Olivia", "Ava", "Isla", "Sophia", "Mia", "Chloe", "Harper", "Evelyn", "Luna", "Aria"];
        const LAST_NAMES = ["Sterling", "Valentine", "Monroe", "Sinclair", "Bellweather", "Rivers", "Knight", "Thorne", "Hayes", "Cole", "Reed", "Morgan", "Gray", "West", "Stone", "Pierce", "Flynn", "Vance", "Blackwood", "Ashford", "Lennox", "Prescott", "Hale", "Shaw", "Grant", "Ford", "Wells", "Clayton", "Bishop", "Page", "Lane", "Fletcher", "Summers", "Winters", "Frost", "Wolfe", "Wilder", "Blaze", "Storm", "Moon", "Starling", "Crowe", "Fox", "Hart", "Brooks", "Lake", "Fields", "Woods", "Marsh"];
        const AI_LABEL_PREFIXES = ["Cosmic", "Groove", "Beat", "Star", "Nova", "Echo", "Rhythm", "Sonic", "Future", "Retro", "Urban", "Indie", "Major", "Global", "Velocity", "Zenith", "Apex", "Crimson", "Azure", "Golden"];
        const AI_LABEL_SUFFIXES = ["Records", "Music", "Sounds", "Group", "Collective", "Audio", "Entertainment", "Labs", "Works", "Factory", "Studio", "Digital", "Wave"];
        const GENRES = ["Pop", "Rock", "Hip Hop", "Electronic", "Indie", "R&B", "Country", "Synthwave", "Lo-Fi", "Jazz", "Classical", "Punk", "Metal", "Folk"];
        const MIN_SIGNING_COST = 5000; MAX_SIGNING_COST = 30000; MIN_SKILL = 20; MAX_SKILL = 70;
        const MIN_POTENTIAL = 50; MAX_POTENTIAL = 95; WEEKLY_ARTIST_COST_PER_SKILL = 5;
        const ARTISTS_PER_WEEK = 2; MAX_AVAILABLE_ARTISTS = 8;
        const CHART_MAX_WEEKS = 12; CHART_DECAY_RATE = 0.85; MIN_CHART_SCORE_TO_STAY = 20;
        const ALBUM_CHART_MAX_WEEKS = 20; ALBUM_CHART_DECAY_RATE = 0.90; MIN_ALBUM_CHART_SCORE_TO_STAY = 30;
        const SONGS_FOR_ALBUM_ELIGIBILITY = 3; POPULARITY_FOR_ALBUM_ELIGIBILITY = 40; SKILL_FOR_ALBUM_ELIGIBILITY = 50;
        const ALBUM_COOLDOWN_WEEKS = 26;
        const SINGLE_BASE_COST = 2000; ALBUM_BASE_COST_FACTOR = 5;
        const MARKETING_COSTS = [0, 5000, 25000, 100000];
        const MARKETING_BOOST = [0, 20, 50, 100];
        const WEEKLY_TRAINING_COST_FACTOR = 15;
        const BASE_TRAINING_IMPROVEMENT_CHANCE = 0.1;
        const POTENTIAL_GAP_TRAINING_BONUS = 0.6;
        const INITIAL_AI_LABELS = 6; // Increased
        const ARTISTS_PER_AI_LABEL = 4; // Increased
        const INITIAL_SIMULATION_WEEKS = 52;
        const AI_LABEL_WEEKLY_ACTION_CHANCE = 0.75;
        const AI_RELEASE_CHANCE_PER_ARTIST = 0.2;
        const AI_TRAIN_CHANCE_PER_ARTIST = 0.1;
        const AI_SIGN_CHANCE = 0.05;
        const MAX_AI_ARTISTS_PER_LABEL = 6; // Slightly increased
        const CONTRACT_WEEKS_STANDARD = 104;
        const MORALE_START = 70;
        const MORALE_HIT_SONG_BONUS = 10;
        const MORALE_HUGE_HIT_BONUS = 20;
        const MORALE_FLOP_PENALTY = -15;
        const MORALE_NO_RELEASE_DECAY_WEEKS = 12;
        const MORALE_NO_RELEASE_PENALTY = -5;
        const MORALE_TRAINING_COST = -2;
        const MORALE_TRAINING_GAIN_BONUS = 5;
        const MORALE_POTENTIAL_REACHED_BONUS = 15;
        const BUZZ_HUGE_HIT_GAIN = 50;
        const BUZZ_GOLD_ALBUM_GAIN = 40;
        const BUZZ_PLATINUM_ALBUM_GAIN = 70;
        const BUZZ_DECAY_RATE = 5;
        const MAX_NEGOTIATION_ROUNDS = 3;
        const RELEASE_FORMATS = { single: [ { id: 'digital_basic', name: 'Digital Basic', costMultiplier: 1.0, qualityEffect: 0, reachBonus: 0, repEffect: 0, description: "Standard digital release. Low cost, standard reach." }, { id: 'digital_premium', name: 'Digital Premium (Promo)', costMultiplier: 1.5, qualityEffect: 2, reachBonus: 10, repEffect: 1, description: "Enhanced digital release with basic online promotion." }, { id: 'physical_limited', name: 'Physical (Limited CD)', costMultiplier: 2.5, qualityEffect: 5, reachBonus: 5, repEffect: 2, description: "Limited run of CDs for die-hard fans and collectors." } ], album: [ { id: 'digital_standard', name: 'Digital Standard', costMultiplier: 1.0, qualityEffect: 0, reachBonus: 0, repEffect: 0, description: "Standard digital album release." }, { id: 'physical_standard', name: 'Physical Standard (CD)', costMultiplier: 2.0, qualityEffect: 3, reachBonus: 15, repEffect: 2, description: "Standard CD release with wider distribution." }, { id: 'deluxe_edition', name: 'Deluxe Edition (CD + Digital)', costMultiplier: 3.5, qualityEffect: 8, reachBonus: 30, repEffect: 5, description: "Premium package with bonus content, high quality production." } ] };
        const CREATIVE_CONTROL_MAP = { label: "Label Controlled", collaborative: "Collaborative", artist: "Artist Controlled" };
        const TOUR_SUPPORT_MAP = { none: "None", basic: "Basic", full: "Full" };
        const MERCH_SPLIT_MAP = { "70/30": "70% (Label) / 30% (Artist)", "50/50": "50% / 50%", "30/70": "30% (Label) / 70% (Artist)" };
        const ADDITIONAL_UNSIGNED_ARTISTS = 30; // Increased
        const NEW_AI_LABEL_CHANCE_PER_YEAR = 0.30; // Increased chance
        const ARTISTS_FOR_NEW_AI_LABEL = 2;


        // --- Core Game Initialization ---
        function initNewGame() { console.log("Attempting to start new game..."); const labelNameInput = document.getElementById('label-name-input'); if (!labelNameInput) { console.error("Label name input not found!"); return; } let labelName = labelNameInput.value.trim() || "My Records"; gameState = { labelName: labelName, money: 50000, reputation: 10, week: 1, artists: [], availableArtists: [], chartingSongs: [], chartingAlbums: [], gameOver: false, message: `Welcome to ${labelName}! The music world awaits...`, artistIdCounter: 0, songIdCounter: 0, albumIdCounter: 0, aiLabelIdCounter: 0, aiArtistIdCounter: 10000, pendingRelease: null, aiLabels: [], currentNegotiation: null, globalUnsignedArtists: [] }; console.log("gameState initialized for new game."); for (let i = 0; i < INITIAL_AI_LABELS; i++) { const aiLabelName = generateAiLabelName(); const newAiLabel = { id: `ai-label-${gameState.aiLabelIdCounter++}`, name: aiLabelName, artists: [], money: 100000 + Math.floor(Math.random() * 100000), reputation: 10 + Math.floor(Math.random() * 20), nextActionAttemptWeek: 1, }; for (let j = 0; j < ARTISTS_PER_AI_LABEL; j++) { newAiLabel.artists.push(generateArtist(true, newAiLabel.name)); } gameState.aiLabels.push(newAiLabel); } console.log("AI labels created."); for (let i = 0; i < 4; i++) { const playerArtist = generateArtist(false); if (playerArtist) gameState.availableArtists.push(playerArtist); } for (let i = 0; i < ADDITIONAL_UNSIGNED_ARTISTS; i++) { gameState.globalUnsignedArtists.push(generateArtist(false, "Unsigned", i + 50000)); } console.log("Player available and global unsigned artists generated."); simulateInitialAIActivity(); console.log("Initial AI simulation complete."); startGameFlow(); updateMessage(gameState.message); console.log("New game started successfully:", labelName); }
        function generateAiLabelName() { const prefix = AI_LABEL_PREFIXES[Math.floor(Math.random() * AI_LABEL_PREFIXES.length)]; const suffix = AI_LABEL_SUFFIXES[Math.floor(Math.random() * AI_LABEL_SUFFIXES.length)]; return `${prefix} ${suffix}`; }
        function simulateInitialAIActivity() { console.log(`Simulating ${INITIAL_SIMULATION_WEEKS} weeks of AI label activity...`); let localAiSongIdCounter = 0; let localAiAlbumIdCounter = 0; for (let week = 0; week < INITIAL_SIMULATION_WEEKS; week++) { gameState.aiLabels.forEach(label => { label.artists.forEach(artist => { artist.weeksSinceRelease++; artist.weeksSinceAlbum++; if (Math.random() < 0.20 && artist.skill < artist.potential) artist.skill = Math.min(artist.potential, artist.skill + 1); if (Math.random() < 0.30) artist.popularity = Math.max(1, Math.min(100, artist.popularity + (Math.random() > 0.4 ? 2 : -1))); const canAiReleaseAlbum = artist.weeksSinceAlbum > (ALBUM_COOLDOWN_WEEKS / 2) && artist.skill > SKILL_FOR_ALBUM_ELIGIBILITY - 20 && artist.popularity > POPULARITY_FOR_ALBUM_ELIGIBILITY - 25; if (canAiReleaseAlbum && Math.random() < AI_RELEASE_CHANCE_PER_ARTIST / 2) { const albumName = `${artist.name} - ${getRandomWord()} Tapes`; const quality = Math.max(30, Math.min(100, Math.floor(artist.skill * 1.3 + (Math.random() * 15 - 5)))); const successScore = (artist.skill * 1.2) + (artist.popularity * 1.5) + quality + (Math.random() * 40) + 15; const criticalScore = Math.max(10, Math.min(100, Math.floor(quality * 0.8 + artist.skill * 0.1 + (Math.random() * 10)))); if (successScore > 110) { addAlbumToChart(albumName, artist.name, Math.floor(successScore), artist.genre, quality, criticalScore, artist.recordLabel, `ai-sim-album-${localAiAlbumIdCounter++}`); } artist.weeksSinceAlbum = 0; artist.popularity = Math.min(100, artist.popularity + (successScore > 150 ? 10 : 4)); } else if (artist.weeksSinceRelease > 1 && Math.random() < AI_RELEASE_CHANCE_PER_ARTIST) { const songName = `${getRandomWord()} ${artist.genre} Flow`; const quality = Math.max(20, Math.min(100, Math.floor(artist.skill * 1.1 + (Math.random() * 10 - 5)))); const successScore = artist.skill + artist.popularity + quality + (Math.random() * 30) + 5; const criticalScore = Math.max(1, Math.min(100, Math.floor(quality * 0.75 + artist.skill * 0.15 + (Math.random() * 10)))); if (successScore > 70) { addSongToChart(songName, artist.name, Math.floor(successScore), artist.genre, quality, criticalScore, artist.recordLabel, `ai-sim-song-${localAiSongIdCounter++}`); } artist.weeksSinceRelease = 0; artist.popularity = Math.min(100, artist.popularity + (successScore > 100 ? 5 : 2)); } }); }); updateCharts(true); } console.log("Initial AI simulation complete (end of function)."); }
        function getRandomWord() { const words = ["Midnight", "Electric", "Velvet", "Golden", "Lost", "Found", "Cosmic", "Urban", "Silent", "Neon", "Future", "Retro", "Diamond", "Shadow", "Crimson", "Azure", "Echo", "Rhythm", "Groove", "Pulse", "Vivid", "Abstract", "Lunar"]; return words[Math.floor(Math.random() * words.length)]; }
        function loadGame() { console.log("Attempting to load game..."); const savedData = localStorage.getItem(SAVE_KEY); const startMenuMessage = document.getElementById('start-menu-message'); if (savedData) { try { const loadedState = JSON.parse(savedData); if (loadedState && loadedState.labelName && loadedState.money !== undefined) { gameState = loadedState; gameState.artistIdCounter = Number(gameState.artistIdCounter) || 0; gameState.songIdCounter = Number(gameState.songIdCounter) || 0; gameState.albumIdCounter = Number(gameState.albumIdCounter) || 0; gameState.aiLabelIdCounter = Number(gameState.aiLabelIdCounter) || 0; gameState.aiArtistIdCounter = Number(gameState.aiArtistIdCounter) || 10000; gameState.artists = gameState.artists || []; gameState.availableArtists = gameState.availableArtists || []; gameState.chartingSongs = gameState.chartingSongs || []; gameState.chartingAlbums = gameState.chartingAlbums || []; gameState.aiLabels = gameState.aiLabels || []; gameState.globalUnsignedArtists = gameState.globalUnsignedArtists || []; gameState.pendingRelease = null; gameState.currentNegotiation = null; gameState.gameOver = gameState.gameOver || false; gameState.artists.forEach(artist => { artist.isTraining = artist.isTraining || false; artist.recordLabel = artist.recordLabel || gameState.labelName; artist.morale = artist.morale === undefined ? MORALE_START : artist.morale; artist.buzz = artist.buzz === undefined ? 0 : artist.buzz; artist.contractWeeksRemaining = artist.contractWeeksRemaining === undefined ? CONTRACT_WEEKS_STANDARD : artist.contractWeeksRemaining; artist.weeksSinceLastReleaseByPlayer = artist.weeksSinceLastReleaseByPlayer === undefined ? 0 : artist.weeksSinceLastReleaseByPlayer; artist.contract = artist.contract || generateInitialDemands(artist); }); gameState.availableArtists.forEach(artist => { artist.recordLabel = artist.recordLabel || "Unsigned"; artist.desiredContract = artist.desiredContract || generateInitialDemands(artist); }); gameState.aiLabels.forEach(label => { label.artists = label.artists || []; label.artists.forEach(aiArtist => { aiArtist.isAI = true; aiArtist.recordLabel = label.name; aiArtist.morale = aiArtist.morale === undefined ? MORALE_START : aiArtist.morale; aiArtist.buzz = aiArtist.buzz === undefined ? 0 : aiArtist.buzz; aiArtist.contract = aiArtist.contract || generateInitialDemands(aiArtist); }); }); console.log("Game data parsed and gameState assigned."); startGameFlow(); updateMessage(`Game loaded for ${gameState.labelName}. Welcome back!`); console.log("Game loaded successfully."); startMenuMessage.textContent = ""; return true; } else { console.error("Loaded save data missing essential properties."); throw new Error("Save data missing essential properties."); } } catch (error) { console.error("Failed to load game in try-catch:", error); startMenuMessage.textContent = "Failed to load save data. It might be corrupted."; localStorage.removeItem(SAVE_KEY); return false; } } else { startMenuMessage.textContent = "No saved game found."; console.log("No saved game data found in localStorage."); return false; } }
        function saveGame() { if (!gameState || gameState.gameOver) { updateMessage("Cannot save game now.", true); return; } try { const stateToSave = { ...gameState }; stateToSave.pendingRelease = null; stateToSave.currentNegotiation = null; const savedData = JSON.stringify(stateToSave); localStorage.setItem(SAVE_KEY, savedData); updateMessage(`Game saved successfully for ${gameState.labelName}! (Week ${gameState.week})`, false); console.log("Game saved."); } catch (error) { console.error("Failed to save game:", error); updateMessage("Error saving game.", true); } }
        function startGameFlow() { console.log("startGameFlow called."); const startMenuEl = document.getElementById('start-menu'); const gameContainerEl = document.getElementById('game-container'); if (startMenuEl && gameContainerEl) { startMenuEl.classList.add('hidden'); gameContainerEl.classList.remove('hidden'); console.log("UI switched: Start menu hidden, game container shown."); updateUI(); } else { console.error("Start menu or game container element not found in startGameFlow!"); } }

        function generateArtist(isAI = false, aiLabelName = "Unsigned", aiSeed = 0) {
            let idToUse;
            if (isAI) { idToUse = `ai-artist-${gameState.aiArtistIdCounter++}`; }
            else { if (!gameState) { console.error("Cannot generate player artist, gameState not initialized."); return null; } idToUse = gameState.artistIdCounter++; }
            const firstName = FIRST_NAMES[Math.floor(Math.random() * FIRST_NAMES.length)];
            const lastName = LAST_NAMES[Math.floor(Math.random() * LAST_NAMES.length)];
            let name = `${firstName} ${lastName}`;
            const recordLabel = isAI ? aiLabelName : "Unsigned";
            const genre = GENRES[Math.floor(Math.random() * GENRES.length)];
            const skill = Math.floor(Math.random() * (MAX_SKILL - MIN_SKILL + 1)) + MIN_SKILL + (isAI ? Math.floor(Math.random() * 10) : 0);
            const potential = Math.max(skill + 5, Math.floor(Math.random() * (MAX_POTENTIAL - MIN_POTENTIAL + 1)) + MIN_POTENTIAL + (isAI ? Math.floor(Math.random() * 5) : 0));
            const popularity = Math.floor(skill / 4) + (isAI ? Math.floor(Math.random() * 10) : 0);
            const signingCost = Math.floor(Math.random() * (MAX_SIGNING_COST - MIN_SIGNING_COST + 1)) + MIN_SIGNING_COST + (skill * 100);
            const weeklyCost = Math.max(100, skill * WEEKLY_ARTIST_COST_PER_SKILL * (1 + Math.random() * 0.2));

            const artistData = {
                id: idToUse, name, recordLabel, genre, skill,
                potential: Math.min(MAX_POTENTIAL, potential),
                popularity: Math.min(100, popularity),
                signingCost, weeklyCost, signed: isAI, songs: [], albums: [],
                weeksSinceRelease: 0, weeksSinceAlbum: 0,
                successfulSingles: (isAI ? Math.floor(Math.random()*4) : 0),
                isTraining: false, isAI: isAI,
                morale: MORALE_START, buzz: 0, contractWeeksRemaining: 0,
                weeksSinceLastReleaseByPlayer: 0,
                desiredContract: null, contract: null
            };
            artistData.desiredContract = generateInitialDemands(artistData);
            if(isAI) artistData.contract = { ...artistData.desiredContract }; // AI artists start with their desired contract
            return artistData;
        }

        function generateInitialDemands(artist) {
            const baseAdvance = artist.signingCost;
            const desiredAdvance = Math.max(1000, Math.floor(baseAdvance * (1 + (artist.popularity / 200) + (artist.potential / 300) + (artist.skill / 250) )));
            let desiredRoyalty = 10 + Math.floor(artist.skill / 10) + Math.floor(artist.popularity / 20) + Math.floor(artist.potential / 25);
            desiredRoyalty = Math.min(40, Math.max(5, desiredRoyalty));
            let desiredAlbumCommitment = 1 + Math.floor(artist.potential / 30);
            desiredAlbumCommitment = Math.min(5, Math.max(1, desiredAlbumCommitment));
            const creativeControlOptions = ["label", "collaborative", "artist"];
            const desiredCreativeControl = creativeControlOptions[Math.floor(Math.random() * creativeControlOptions.length)];
            const tourSupportOptions = ["none", "basic", "full"];
            const desiredTourSupport = tourSupportOptions[Math.floor(Math.random() * tourSupportOptions.length)];
            const merchSplitOptions = ["70/30", "50/50", "30/70"];
            const desiredMerchSplit = merchSplitOptions[Math.floor(Math.random() * merchSplitOptions.length)];
            return { advance: desiredAdvance, royaltyRate: desiredRoyalty, albumCommitment: desiredAlbumCommitment, creativeControl: desiredCreativeControl, tourSupport: desiredTourSupport, merchSplit: desiredMerchSplit };
        }

        // --- Contract Negotiation Logic ---
        function openContractNegotiationModal(artistId) {
            if (!gameState) return;
            // Try finding in availableArtists first, then globalUnsignedArtists
            let artist = gameState.availableArtists.find(a => a.id === artistId);
            let sourceList = 'availableArtists';
            if (!artist) {
                artist = gameState.globalUnsignedArtists.find(a => a.id === artistId);
                sourceList = 'globalUnsignedArtists';
            }

            if (!artist) { updateMessage("Artist not found for negotiation.", true); return; }
            if (!artist.desiredContract) artist.desiredContract = generateInitialDemands(artist);

            gameState.currentNegotiation = {
                artistId: artistId,
                artistSourceList: sourceList, // Store where the artist came from
                artistDemands: { ...artist.desiredContract },
                playerOffer: { ...artist.desiredContract },
                round: 1, maxRounds: MAX_NEGOTIATION_ROUNDS,
                artistPatience: 100
            };

            const modal = document.getElementById('contract-negotiation-modal');
            document.getElementById('contract-modal-title').textContent = `Negotiate with ${artist.name}`;
            document.getElementById('contract-artist-name').textContent = artist.name;
            document.getElementById('contract-artist-stats').textContent = `Skill: ${artist.skill}, Pot: ${artist.potential}, Pop: ${artist.popularity}, Genre: ${artist.genre}`;
            updateContractModalUI();
            document.getElementById('negotiation-feedback').classList.add('hidden');
            document.getElementById('negotiation-feedback').textContent = '';
            modal.classList.add('active');
        }

        function updateContractModalUI() { const neg = gameState.currentNegotiation; if (!neg) return; document.getElementById('artist-demand-advance').textContent = `$${neg.artistDemands.advance.toLocaleString()}`; document.getElementById('artist-demand-royalty').textContent = `${neg.artistDemands.royaltyRate}`; document.getElementById('artist-demand-albums').textContent = `${neg.artistDemands.albumCommitment}`; document.getElementById('artist-demand-creative-control').textContent = CREATIVE_CONTROL_MAP[neg.artistDemands.creativeControl] || neg.artistDemands.creativeControl; document.getElementById('artist-demand-tour-support').textContent = TOUR_SUPPORT_MAP[neg.artistDemands.tourSupport] || neg.artistDemands.tourSupport; document.getElementById('artist-demand-merch-split').textContent = MERCH_SPLIT_MAP[neg.artistDemands.merchSplit] || neg.artistDemands.merchSplit; const advanceSlider = document.getElementById('negotiate-advance'); advanceSlider.value = neg.playerOffer.advance; advanceSlider.max = Math.max(100000, neg.artistDemands.advance * 1.5); document.getElementById('player-offer-advance-value').textContent = `$${Number(advanceSlider.value).toLocaleString()}`; const royaltySlider = document.getElementById('negotiate-royalty'); royaltySlider.value = neg.playerOffer.royaltyRate; document.getElementById('player-offer-royalty-value').textContent = `${royaltySlider.value}%`; const albumsSlider = document.getElementById('negotiate-albums'); albumsSlider.value = neg.playerOffer.albumCommitment; document.getElementById('player-offer-albums-value').textContent = `${albumsSlider.value}`; document.getElementById('negotiate-creative-control').value = neg.playerOffer.creativeControl; document.getElementById('negotiate-tour-support').value = neg.playerOffer.tourSupport; document.getElementById('negotiate-merch-split').value = neg.playerOffer.merchSplit; document.getElementById('negotiation-round').textContent = neg.round; document.getElementById('negotiation-max-rounds').textContent = neg.maxRounds; }
        function setupContractNegotiationListeners() { document.getElementById('negotiate-advance').addEventListener('input', (e) => { if(gameState.currentNegotiation) { gameState.currentNegotiation.playerOffer.advance = parseInt(e.target.value); updateContractModalUI(); }}); document.getElementById('negotiate-royalty').addEventListener('input', (e) => { if(gameState.currentNegotiation) {gameState.currentNegotiation.playerOffer.royaltyRate = parseInt(e.target.value); updateContractModalUI(); }}); document.getElementById('negotiate-albums').addEventListener('input', (e) => { if(gameState.currentNegotiation) {gameState.currentNegotiation.playerOffer.albumCommitment = parseInt(e.target.value); updateContractModalUI(); }}); document.getElementById('negotiate-creative-control').addEventListener('change', (e) => { if(gameState.currentNegotiation) {gameState.currentNegotiation.playerOffer.creativeControl = e.target.value; updateContractModalUI(); }}); document.getElementById('negotiate-tour-support').addEventListener('change', (e) => { if(gameState.currentNegotiation) {gameState.currentNegotiation.playerOffer.tourSupport = e.target.value; updateContractModalUI(); }}); document.getElementById('negotiate-merch-split').addEventListener('change', (e) => { if(gameState.currentNegotiation) {gameState.currentNegotiation.playerOffer.merchSplit = e.target.value; updateContractModalUI(); }}); document.getElementById('contract-make-offer-btn').addEventListener('click', handlePlayerContractOffer); document.getElementById('contract-accept-artist-btn').addEventListener('click', handleAcceptArtistTerms); document.getElementById('contract-walk-away-btn').addEventListener('click', () => closeContractNegotiationModal(false, "You walked away from the deal.")); }
        function handlePlayerContractOffer() { if (!gameState || !gameState.currentNegotiation) return; const neg = gameState.currentNegotiation; const artist = gameState[neg.artistSourceList].find(a => a.id === neg.artistId); let acceptanceScore = 0; const pOffer = neg.playerOffer; const aDemands = neg.artistDemands; const advanceRatio = pOffer.advance / aDemands.advance; if (advanceRatio >= 1) acceptanceScore += Math.min(50, (advanceRatio - 1) * 50 + 25); else acceptanceScore += (advanceRatio - 1) * 50; const royaltyRatio = pOffer.royaltyRate / aDemands.royaltyRate; if (royaltyRatio >= 1) acceptanceScore += Math.min(50, (royaltyRatio - 1) * 50 + 25); else acceptanceScore += (royaltyRatio - 1) * 50; const albumDiff = aDemands.albumCommitment - pOffer.albumCommitment; acceptanceScore += Math.max(-30, Math.min(30, albumDiff * 10)); const ccValues = { label: 0, collaborative: 10, artist: 20 }; acceptanceScore += ccValues[pOffer.creativeControl] - ccValues[aDemands.creativeControl]; const tsValues = { none: 0, basic: 10, full: 20 }; acceptanceScore += tsValues[pOffer.tourSupport] - tsValues[aDemands.tourSupport]; const msValues = { "70/30": 0, "50/50": 10, "30/70": 20 }; acceptanceScore += msValues[pOffer.merchSplit] - msValues[aDemands.merchSplit]; acceptanceScore += gameState.reputation / 2; acceptanceScore -= neg.round * 10; acceptanceScore += Math.floor(Math.random() * 21) - 10; const feedbackEl = document.getElementById('negotiation-feedback'); feedbackEl.classList.remove('hidden'); if (acceptanceScore >= 70 || (neg.round === neg.maxRounds && acceptanceScore >= 55)) { feedbackEl.textContent = `${artist.name} accepts your offer!`; finalizeContract(artist, neg.playerOffer, neg.artistSourceList); } else if (neg.round >= neg.maxRounds || acceptanceScore < 30) { feedbackEl.textContent = `${artist.name} isn't happy with the offers and walks away.`; closeContractNegotiationModal(false, `${artist.name} walked away from the deal.`); } else { neg.round++; feedbackEl.textContent = `${artist.name} considers your offer... and counters!`; Object.keys(aDemands).forEach(key => { if (typeof aDemands[key] === 'number') { aDemands[key] = Math.floor((aDemands[key] + pOffer[key]) / 2); } else { if (Math.random() < 0.4) aDemands[key] = pOffer[key]; } }); aDemands.advance = Math.max(1000, aDemands.advance); aDemands.royaltyRate = Math.max(5, Math.min(50, aDemands.royaltyRate)); aDemands.albumCommitment = Math.max(1, Math.min(5, aDemands.albumCommitment)); neg.playerOffer = { ...aDemands }; updateContractModalUI(); } }
        function handleAcceptArtistTerms() { if (!gameState || !gameState.currentNegotiation) return; const neg = gameState.currentNegotiation; const artist = gameState[neg.artistSourceList].find(a => a.id === neg.artistId); if (gameState.money < neg.artistDemands.advance) { document.getElementById('negotiation-feedback').textContent = `You cannot afford their current demand of $${neg.artistDemands.advance.toLocaleString()} for an advance.`; document.getElementById('negotiation-feedback').classList.remove('hidden'); return; } document.getElementById('negotiation-feedback').textContent = `You accept ${artist.name}'s terms!`; finalizeContract(artist, neg.artistDemands, neg.artistSourceList); }
        function finalizeContract(artist, agreedTerms, sourceList) { if (gameState.money < agreedTerms.advance) { updateMessage(`Cannot finalize deal: Insufficient funds for $${agreedTerms.advance.toLocaleString()} advance.`, true); closeContractNegotiationModal(false, "Deal fell through due to insufficient funds for advance."); return; } gameState.money -= agreedTerms.advance; artist.signed = true; artist.isAI = false; artist.recordLabel = gameState.labelName; artist.weeksSinceRelease = 0; artist.weeksSinceAlbum = 0; artist.isTraining = false; artist.morale = MORALE_START; artist.buzz = 0; artist.contractWeeksRemaining = CONTRACT_WEEKS_STANDARD; artist.weeksSinceLastReleaseByPlayer = 0; artist.contract = { ...agreedTerms }; const artistIndex = gameState[sourceList].findIndex(a => a.id === artist.id); if (artistIndex > -1) gameState[sourceList].splice(artistIndex, 1); gameState.artists.push(artist); updateMessage(`Successfully signed ${artist.name} to ${gameState.labelName}! Advance paid: $${agreedTerms.advance.toLocaleString()}.`, false); closeContractNegotiationModal(true); }
        function closeContractNegotiationModal(signedSuccessfully = false, message = "") { document.getElementById('contract-negotiation-modal').classList.remove('active'); if (message && !signedSuccessfully) { updateMessage(message, true); } gameState.currentNegotiation = null; updateUI(); }
        function signArtist(artistId) { if (!gameState) return; openContractNegotiationModal(artistId); }
        function toggleTraining(artistId) { if (!gameState) return; const artist = gameState.artists.find(a => a.id === artistId); if (!artist) { updateMessage("Artist not found.", true); return; } if (artist.skill >= artist.potential) { updateMessage(`${artist.name} has reached full potential!`, true); return; } const weeklyCost = calculateTrainingCost(artist); if (!artist.isTraining) { if (gameState.money < weeklyCost * 2) { updateMessage(`Not enough money to start training ${artist.name} (Need ~$${(weeklyCost * 2).toLocaleString()} buffer).`, true); return; } artist.isTraining = true; updateMessage(`${artist.name} started training. Cost: $${weeklyCost.toLocaleString()}/week.`, false); } else { artist.isTraining = false; updateMessage(`${artist.name} stopped training.`, false); } updateUI(); }
        function calculateTrainingCost(artist) { return Math.max(50, Math.floor(artist.skill * WEEKLY_TRAINING_COST_FACTOR)); }
        function handleWeeklyTraining(artist) { if (!artist.isTraining || artist.skill >= artist.potential) { artist.isTraining = false; return 0; } const cost = calculateTrainingCost(artist); if (gameState.money < cost) { artist.isTraining = false; updateMessage(`${artist.name} stopped training (lack of funds)!`, true); updateUI(); return 0; } gameState.money -= cost; artist.morale = Math.max(0, artist.morale + MORALE_TRAINING_COST); const potentialGap = artist.potential - artist.skill; const gapBonus = (potentialGap / (MAX_POTENTIAL - MIN_SKILL)) * POTENTIAL_GAP_TRAINING_BONUS; const improvementChance = BASE_TRAINING_IMPROVEMENT_CHANCE + gapBonus; if (Math.random() < improvementChance) { artist.skill++; artist.morale = Math.min(100, artist.morale + MORALE_TRAINING_GAIN_BONUS); if (artist.skill >= artist.potential) { artist.isTraining = false; artist.morale = Math.min(100, artist.morale + MORALE_POTENTIAL_REACHED_BONUS); updateMessage(`✨ ${artist.name} reached potential (${artist.skill}) through training! Morale up!`, false); } } return cost; }
        function openReleaseModal(artistId, releaseType) { if (!gameState) return; const artist = gameState.artists.find(a => a.id === artistId); if (!artist) { updateMessage("Error: Artist not found.", true); return; } if (artist.isTraining) { updateMessage(`${artist.name} cannot release music while training.`, true); return; } let baseCost = 0; if (releaseType === 'single') { baseCost = SINGLE_BASE_COST + Math.floor(artist.skill * 50); } else if (releaseType === 'album') { if (!canArtistReleaseAlbum(artist, true)) { updateMessage(`${artist.name} is not ready for an album. ${getAlbumEligibilityReason(artist, true)}`, true); return; } const singleBase = SINGLE_BASE_COST + Math.floor(artist.skill * 50); baseCost = (singleBase * ALBUM_BASE_COST_FACTOR) + (artist.popularity * 100); } gameState.pendingRelease = { artistId, releaseType, baseCost }; const modal = document.getElementById('release-modal'); document.getElementById('modal-title').textContent = `Release New ${capitalizeFirstLetter(releaseType)} for ${artist.name}`; document.getElementById('modal-artist-info').textContent = `Artist: ${artist.name} (Skill: ${artist.skill}, Pop: ${artist.popularity}, Morale: ${artist.morale}, Buzz: ${artist.buzz})`; document.getElementById('modal-release-type').textContent = `Type: ${capitalizeFirstLetter(releaseType)}`; const releaseNameInput = document.getElementById('release-name-input'); releaseNameInput.value = releaseType === 'single' ? `${artist.genre} Hit #${artist.songs.length + 1}` : `${artist.name} - The ${getRandomWord()} LP`; const formatSelect = document.getElementById('release-format-select'); const formatDescription = document.getElementById('release-format-description'); formatSelect.innerHTML = ''; const availableFormats = RELEASE_FORMATS[releaseType] || []; availableFormats.forEach(format => { const option = document.createElement('option'); option.value = format.id; option.textContent = format.name; option.dataset.description = format.description; formatSelect.appendChild(option); }); if (availableFormats.length > 0) { formatDescription.textContent = availableFormats[0].description; } else { formatDescription.textContent = "No formats available."; } document.getElementById('modal-base-cost').textContent = `$${baseCost.toLocaleString()}`; const marketingSelect = document.getElementById('marketing-level'); marketingSelect.innerHTML = ''; MARKETING_COSTS.forEach((cost, level) => { const option = document.createElement('option'); option.value = level; option.textContent = `${getMarketingLevelName(level)} ($${cost.toLocaleString()})`; marketingSelect.appendChild(option); }); marketingSelect.value = 0; updateTotalCost(); modal.classList.add('active'); }
        function closeReleaseModal() { document.getElementById('release-modal').classList.remove('active'); if(gameState) gameState.pendingRelease = null; const confirmBtn = document.getElementById('modal-confirm-btn'); const cancelBtn = document.getElementById('modal-cancel-btn'); if(confirmBtn) { confirmBtn.disabled = false; confirmBtn.textContent = 'Confirm Release'; confirmBtn.classList.remove('btn-disabled'); confirmBtn.removeAttribute('title'); } if(cancelBtn) { cancelBtn.disabled = false; cancelBtn.classList.remove('btn-disabled'); } }
        function updateTotalCost() { if (!gameState || !gameState.pendingRelease) return; console.log("updateTotalCost called. Pending release:", gameState.pendingRelease); let calculatedBaseCost = gameState.pendingRelease.baseCost; const releaseType = gameState.pendingRelease.releaseType; const formatSelect = document.getElementById('release-format-select'); const selectedFormatId = formatSelect.value; const format = (RELEASE_FORMATS[releaseType] || []).find(f => f.id === selectedFormatId); if (format) { calculatedBaseCost = gameState.pendingRelease.baseCost * format.costMultiplier; document.getElementById('release-format-description').textContent = format.description; } const marketingLevel = parseInt(document.getElementById('marketing-level').value); const marketingCost = MARKETING_COSTS[marketingLevel]; const totalCost = Math.floor(calculatedBaseCost) + marketingCost; document.getElementById('modal-total-cost').textContent = `$${totalCost.toLocaleString()}`; const confirmBtn = document.getElementById('modal-confirm-btn'); if (!confirmBtn) { console.error("CRITICAL: modal-confirm-btn NOT FOUND in updateTotalCost!"); return; } if (gameState.money < totalCost) { confirmBtn.disabled = true; confirmBtn.classList.add('btn-disabled'); confirmBtn.title = "Not enough money!"; } else { confirmBtn.disabled = false; confirmBtn.classList.remove('btn-disabled'); confirmBtn.removeAttribute('title'); } console.log("updateTotalCost finished. Confirm button disabled:", confirmBtn.disabled); }
        function confirmRelease() { if (!gameState || !gameState.pendingRelease) return; const confirmBtn = document.getElementById('modal-confirm-btn'); const cancelBtn = document.getElementById('modal-cancel-btn'); if(!confirmBtn || !cancelBtn) { console.error("Modal buttons not found in confirmRelease"); return; } const { artistId, releaseType, baseCost: originalBaseCost } = gameState.pendingRelease; const artist = gameState.artists.find(a => a.id === artistId); const releaseNameInput = document.getElementById('release-name-input'); let releaseName = releaseNameInput.value.trim(); if (!releaseName) { releaseName = releaseType === 'single' ? `${artist.genre} Single #${artist.songs.length + 1}` : `${artist.name} - The Collection #${artist.albums.length + 1}`; } const formatSelect = document.getElementById('release-format-select'); const selectedFormatId = formatSelect.value; const selectedFormat = (RELEASE_FORMATS[releaseType] || []).find(f => f.id === selectedFormatId); if (!selectedFormat) { updateMessage("Error: Invalid release format selected.", true); return; } let currentBaseCost = originalBaseCost * selectedFormat.costMultiplier; const marketingLevel = parseInt(document.getElementById('marketing-level').value); const marketingCost = MARKETING_COSTS[marketingLevel]; const totalCost = Math.floor(currentBaseCost) + marketingCost; if (gameState.money < totalCost) { updateMessage("Error: Cannot afford this release.", true); return; } confirmBtn.disabled = true; confirmBtn.textContent = 'Processing...'; confirmBtn.classList.add('btn-disabled'); cancelBtn.disabled = true; cancelBtn.classList.add('btn-disabled'); setTimeout(() => { try { if (!gameState) throw new Error("Game state lost."); gameState.money -= totalCost; if (releaseType === 'single') executeSingleRelease(artist, marketingLevel, totalCost, releaseName, selectedFormat); else if (releaseType === 'album') executeAlbumRelease(artist, marketingLevel, totalCost, releaseName, selectedFormat); } catch (e) { console.error("Error during release:", e); updateMessage("Error during release.", true); } finally { closeReleaseModal(); updateUI(); } }, 100); }
        function executeSingleRelease(artist, marketingLevel, totalCost, releaseName, format) { if (!gameState) return; gameState.songIdCounter++; const moraleFactor = (artist.morale / 100) * 0.2 + 0.9; const quality = Math.max(10, Math.min(100, Math.floor(artist.skill * 1.2 * moraleFactor + (Math.random() * 20 - 10) + format.qualityEffect))); const baseSuccess = artist.skill + artist.popularity + quality + artist.buzz + format.reachBonus; const marketingBoost = MARKETING_BOOST[marketingLevel]; const randomFactor = Math.random() * 40; const successScore = Math.floor(baseSuccess + marketingBoost + randomFactor); const criticalScore = Math.max(1, Math.min(100, Math.floor(quality * 0.8 + artist.skill * 0.2 + (Math.random() * 15 - 5)))); let earnings = 0, reputationChange = format.repEffect, message = ""; if (successScore > 150 + marketingBoost/2) { earnings = Math.floor(totalCost * (4 + Math.random() * 4 + quality / 25)); reputationChange += 4 + Math.floor(Math.random() * 4) + Math.floor(criticalScore / 20); message = `🔥 HUGE HIT! [Q:${quality}, C:${criticalScore}] "${releaseName}" by ${artist.name} is a smash! Earned $${earnings.toLocaleString()}. Rep +${reputationChange}.`; artist.popularity = Math.min(100, artist.popularity + 10 + Math.floor(Math.random() * 8 + quality / 10)); artist.skill = Math.min(artist.potential, artist.skill + Math.floor(Math.random() * 2) + 1); addSongToChart(releaseName, artist.name, successScore, artist.genre, quality, criticalScore, artist.recordLabel); artist.successfulSingles++; artist.morale = Math.min(100, artist.morale + MORALE_HUGE_HIT_BONUS); artist.buzz = Math.min(100, artist.buzz + BUZZ_HUGE_HIT_GAIN); } else if (successScore > 90 + marketingBoost/3) { earnings = Math.floor(totalCost * (1.2 + Math.random() * 1.5 + quality / 40)); reputationChange += 1 + Math.floor(Math.random() * 2) + Math.floor(criticalScore / 30); message = `👍 Hit Song! [Q:${quality}, C:${criticalScore}] "${releaseName}" by ${artist.name} is doing well. Earned $${earnings.toLocaleString()}. Rep +${reputationChange}.`; artist.popularity = Math.min(100, artist.popularity + 4 + Math.floor(Math.random() * 4 + quality / 15)); artist.skill = Math.min(artist.potential, artist.skill + (Math.random() > 0.5 ? 1 : 0)); addSongToChart(releaseName, artist.name, successScore, artist.genre, quality, criticalScore, artist.recordLabel); artist.successfulSingles++; artist.morale = Math.min(100, artist.morale + MORALE_HIT_SONG_BONUS); } else if (successScore > 50) { earnings = Math.floor(totalCost * (0.6 + Math.random() * 0.6 + quality / 100)); reputationChange += (criticalScore > 50 ? 1 : 0); message = `😐 Okay reception [Q:${quality}, C:${criticalScore}] for "${releaseName}" by ${artist.name}. Earned $${earnings.toLocaleString()}.`; artist.popularity = Math.min(100, artist.popularity + 1 + Math.floor(Math.random() * 2)); } else { earnings = Math.floor(totalCost * (0.1 + Math.random() * 0.3)); reputationChange += -1 - Math.floor(Math.random() * 2) + (criticalScore < 30 ? -1 : 0); message = `😭 Flop! [Q:${quality}, C:${criticalScore}] "${releaseName}" by ${artist.name} missed the mark. Earned $${earnings.toLocaleString()}. Rep ${reputationChange}.`; artist.popularity = Math.max(1, artist.popularity - 2); artist.morale = Math.max(0, artist.morale + MORALE_FLOP_PENALTY); } gameState.money += earnings; gameState.reputation = Math.max(0, gameState.reputation + reputationChange); artist.songs.push({ id: `song-${gameState.songIdCounter}`, name: releaseName, quality, criticalScore, earnings, weekReleased: gameState.week, format: format.id }); artist.weeksSinceRelease = 0; artist.weeksSinceLastReleaseByPlayer = 0; updateMessage(message); }
        function executeAlbumRelease(artist, marketingLevel, totalCost, releaseName, format) { if (!gameState) return; gameState.albumIdCounter++; const moraleFactor = (artist.morale / 100) * 0.2 + 0.9; const quality = Math.max(20, Math.min(100, Math.floor(artist.skill * 1.4 * moraleFactor + (Math.random() * 25 - 10) + format.qualityEffect))); const baseSuccess = (artist.skill * 1.2) + (artist.popularity * 1.5) + quality + artist.buzz + format.reachBonus; const marketingBoost = MARKETING_BOOST[marketingLevel] * 1.5; const randomFactor = Math.random() * 50; const successScore = Math.floor(baseSuccess + marketingBoost + randomFactor); const criticalScore = Math.max(1, Math.min(100, Math.floor(quality * 0.9 + artist.skill * 0.15 + (Math.random() * 10 - 5)))); let earnings = 0, reputationChange = format.repEffect, msg = ""; if (successScore > 250 + marketingBoost/1.5) { earnings = Math.floor(totalCost * (4 + Math.random() * 5 + quality / 15)); reputationChange += 8 + Math.floor(Math.random() * 8) + Math.floor(criticalScore / 15); artist.popularity = Math.min(100, artist.popularity + 15 + Math.floor(Math.random() * 10 + quality / 8)); artist.skill = Math.min(artist.potential, artist.skill + 2 + Math.floor(Math.random() * 3)); msg = `🌟 PLATINUM! [Q:${quality}, C:${criticalScore}] "${releaseName}" by ${artist.name} is huge! Earned: $${earnings.toLocaleString()}. Rep +${reputationChange}.`; addAlbumToChart(releaseName, artist.name, successScore, artist.genre, quality, criticalScore, artist.recordLabel); artist.morale = Math.min(100, artist.morale + MORALE_HUGE_HIT_BONUS + 10); artist.buzz = Math.min(100, artist.buzz + BUZZ_PLATINUM_ALBUM_GAIN); } else if (successScore > 150 + marketingBoost/2) { earnings = Math.floor(totalCost * (1.8 + Math.random() * 2 + quality / 25)); reputationChange += 4 + Math.floor(Math.random() * 4) + Math.floor(criticalScore / 20); artist.popularity = Math.min(100, artist.popularity + 8 + Math.floor(Math.random() * 6 + quality / 12)); artist.skill = Math.min(artist.potential, artist.skill + 1 + Math.floor(Math.random() * 2)); msg = `📀 GOLD! [Q:${quality}, C:${criticalScore}] "${releaseName}" by ${artist.name} sells well! Earned: $${earnings.toLocaleString()}. Rep +${reputationChange}.`; addAlbumToChart(releaseName, artist.name, successScore, artist.genre, quality, criticalScore, artist.recordLabel); artist.morale = Math.min(100, artist.morale + MORALE_HIT_SONG_BONUS + 5); artist.buzz = Math.min(100, artist.buzz + BUZZ_GOLD_ALBUM_GAIN); } else { earnings = Math.floor(totalCost * (0.3 + Math.random() * 0.4 + quality / 150)); reputationChange += -2 - Math.floor(Math.random() * 3) + (criticalScore < 40 ? -2 : 0); artist.popularity = Math.max(1, artist.popularity - 5 - Math.floor(Math.random() * 5)); msg = `😕 Disappointment [Q:${quality}, C:${criticalScore}] "${releaseName}" by ${artist.name} underperformed. Earned: $${earnings.toLocaleString()}. Rep ${reputationChange}.`; artist.morale = Math.max(0, artist.morale + MORALE_FLOP_PENALTY - 5); } gameState.money += earnings; gameState.reputation = Math.max(0, gameState.reputation + reputationChange); artist.albums.push({ id: `album-${gameState.albumIdCounter}`, name: releaseName, quality, criticalScore, earnings, weekReleased: gameState.week, format: format.id }); artist.weeksSinceAlbum = 0; artist.successfulSingles = Math.max(0, artist.successfulSingles - 2); artist.weeksSinceLastReleaseByPlayer = 0; updateMessage(msg); }
        function canArtistReleaseAlbum(artist, ignorePlayerCooldown = false) { const cooldownMet = artist.isAI ? (artist.weeksSinceAlbum >= ALBUM_COOLDOWN_WEEKS) : (ignorePlayerCooldown ? true : false); if (artist.isAI) { return cooldownMet && artist.skill > SKILL_FOR_ALBUM_ELIGIBILITY - 10 && artist.popularity > POPULARITY_FOR_ALBUM_ELIGIBILITY - 10; } return artist.successfulSingles >= SONGS_FOR_ALBUM_ELIGIBILITY && artist.popularity >= POPULARITY_FOR_ALBUM_ELIGIBILITY && artist.skill >= SKILL_FOR_ALBUM_ELIGIBILITY; }
        function getAlbumEligibilityReason(artist, ignorePlayerCooldown = false) { if (artist.successfulSingles < SONGS_FOR_ALBUM_ELIGIBILITY) return `Needs ${SONGS_FOR_ALBUM_ELIGIBILITY - artist.successfulSingles} more hit singles.`; if (artist.popularity < POPULARITY_FOR_ALBUM_ELIGIBILITY) return `Needs Pop ${POPULARITY_FOR_ALBUM_ELIGIBILITY}.`; if (artist.skill < SKILL_FOR_ALBUM_ELIGIBILITY) return `Needs Skill ${SKILL_FOR_ALBUM_ELIGIBILITY}.`; if (artist.isAI && !ignorePlayerCooldown && artist.weeksSinceAlbum < ALBUM_COOLDOWN_WEEKS) return `Cooldown: ${ALBUM_COOLDOWN_WEEKS - artist.weeksSinceAlbum}w left.`; return "Not ready"; }
        function addSongToChart(songName, artistName, initialScore, genre, quality, criticalScore, recordLabel, chartId = null) { if (!gameState) return; let finalChartId = chartId || (recordLabel === gameState.labelName ? `song-${gameState.songIdCounter}` : `song-ai-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`); const existingArtistSongsOnChart = gameState.chartingSongs.filter(s => s.artistName === artistName && s.recordLabel === recordLabel).length; if (recordLabel === gameState.labelName && existingArtistSongsOnChart >= 2 && initialScore < 120) return; gameState.chartingSongs.push({ id: finalChartId, songName, artistName, recordLabel, genre, quality, criticalScore, currentChartScore: initialScore, initialScore, weeksOnChart: 0 }); sortAndTrimChart(gameState.chartingSongs, 20); }
        function addAlbumToChart(albumName, artistName, initialScore, genre, quality, criticalScore, recordLabel, chartId = null) { if (!gameState) return; let finalChartId = chartId || (recordLabel === gameState.labelName ? `album-${gameState.albumIdCounter}` : `album-ai-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`); const existingArtistAlbumsOnChart = gameState.chartingAlbums.filter(a => a.artistName === artistName && a.recordLabel === recordLabel).length; if (recordLabel === gameState.labelName && existingArtistAlbumsOnChart >= 1 && initialScore < 200) return; gameState.chartingAlbums.push({ id: finalChartId, albumName, artistName, recordLabel, genre, quality, criticalScore, currentChartScore: initialScore, initialScore, weeksOnChart: 0 }); sortAndTrimChart(gameState.chartingAlbums, 15); }
        function updateCharts(isSimulation = false) { if (!gameState) return; gameState.chartingSongs.forEach(s => { s.weeksOnChart++; s.currentChartScore = Math.floor(s.currentChartScore * CHART_DECAY_RATE); }); gameState.chartingSongs = gameState.chartingSongs.filter(s => s.weeksOnChart <= CHART_MAX_WEEKS && s.currentChartScore >= MIN_CHART_SCORE_TO_STAY); sortAndTrimChart(gameState.chartingSongs, 20); gameState.chartingAlbums.forEach(a => { a.weeksOnChart++; a.currentChartScore = Math.floor(a.currentChartScore * ALBUM_CHART_DECAY_RATE); }); gameState.chartingAlbums = gameState.chartingAlbums.filter(a => a.weeksOnChart <= ALBUM_CHART_MAX_WEEKS && a.currentChartScore >= MIN_ALBUM_CHART_SCORE_TO_STAY); sortAndTrimChart(gameState.chartingAlbums, 15); }
        function sortAndTrimChart(chartArray, maxSize) { chartArray.sort((a, b) => b.currentChartScore - a.currentChartScore); if (chartArray.length > maxSize) chartArray.length = maxSize; }
        function nextWeek() { if (!gameState || gameState.gameOver) return; gameState.week++; let totalWeeklyExpenses = 0; let trainingCosts = 0; gameState.artists.forEach(artist => { totalWeeklyExpenses += artist.weeklyCost; artist.weeksSinceRelease++; artist.weeksSinceAlbum++; artist.weeksSinceLastReleaseByPlayer++; artist.buzz = Math.max(0, artist.buzz - BUZZ_DECAY_RATE); if (artist.isTraining) { trainingCosts += handleWeeklyTraining(artist); } else { if (Math.random() < 0.08 && artist.skill < artist.potential) artist.skill++; if (Math.random() < 0.15) artist.popularity = Math.max(1, artist.popularity + (Math.random() > 0.65 ? 1 : -1)); } if (artist.weeksSinceLastReleaseByPlayer > MORALE_NO_RELEASE_DECAY_WEEKS && artist.songs.length > 0) { artist.morale = Math.max(0, artist.morale + MORALE_NO_RELEASE_PENALTY); if (artist.weeksSinceLastReleaseByPlayer % 4 === 0) { updateMessage(`${artist.name} is feeling neglected (no releases in ${artist.weeksSinceLastReleaseByPlayer} weeks). Morale down.`, true); } } }); totalWeeklyExpenses += trainingCosts; for (let i = 0; i < ARTISTS_PER_WEEK; i++) { if (gameState.availableArtists.length < MAX_AVAILABLE_ARTISTS) { const newArtist = generateArtist(false); if (newArtist) gameState.availableArtists.push(newArtist); } } while(gameState.availableArtists.length > MAX_AVAILABLE_ARTISTS) { gameState.availableArtists.shift(); } gameState.aiLabels.forEach(label => { if (gameState.week >= label.nextActionAttemptWeek) { if (Math.random() < AI_LABEL_WEEKLY_ACTION_CHANCE) { const artistToManage = label.artists.length > 0 ? label.artists[Math.floor(Math.random() * label.artists.length)] : null; if (artistToManage && Math.random() < AI_RELEASE_CHANCE_PER_ARTIST) { const isAlbum = Math.random() < 0.2 && canArtistReleaseAlbum(artistToManage, false); if (isAlbum) { const albumName = `${artistToManage.name} - ${getRandomWord()} Dreams`; const quality = Math.max(25, Math.min(100, Math.floor(artistToManage.skill * 1.25 + (Math.random() * 10)))); const successScore = (artistToManage.skill * 1.15) + (artistToManage.popularity * 1.4) + quality + (Math.random() * 30); const criticalScore = Math.max(10, Math.min(100, Math.floor(quality * 0.75 + artistToManage.skill * 0.1))); if (successScore > 120) { addAlbumToChart(albumName, artistToManage.name, Math.floor(successScore), artistToManage.genre, quality, criticalScore, label.name, `ai-album-${label.id}-${gameState.week}`); } artistToManage.weeksSinceAlbum = 0; } else if (artistToManage.weeksSinceRelease > ALBUM_COOLDOWN_WEEKS / 4 ) { const songName = `${getRandomWord()} ${artistToManage.genre} Beat`; const quality = Math.max(20, Math.min(100, Math.floor(artistToManage.skill * 1.05 + (Math.random() * 10)))); const successScore = artistToManage.skill + artistToManage.popularity + quality + (Math.random() * 25); const criticalScore = Math.max(5, Math.min(100, Math.floor(quality * 0.7 + artistToManage.skill * 0.1))); if (successScore > 80) { addSongToChart(songName, artistToManage.name, Math.floor(successScore), artistToManage.genre, quality, criticalScore, label.name, `ai-song-${label.id}-${gameState.week}`); } artistToManage.weeksSinceRelease = 0; } } else if (artistToManage && Math.random() < AI_TRAIN_CHANCE_PER_ARTIST && artistToManage.skill < artistToManage.potential && !artistToManage.isTraining) { artistToManage.isTraining = true; } else if (label.artists.length < MAX_AI_ARTISTS_PER_LABEL && Math.random() < AI_SIGN_CHANCE) { const newAIArtist = generateArtist(true, label.name); if (newAIArtist) label.artists.push(newAIArtist); } } label.nextActionAttemptWeek = gameState.week + Math.floor(Math.random() * 4) + 1; } label.artists.forEach(artist => { if (artist.isTraining) { if (Math.random() < BASE_TRAINING_IMPROVEMENT_CHANCE + 0.25 && artist.skill < artist.potential) artist.skill++; if (artist.skill >= artist.potential || Math.random() < 0.1) artist.isTraining = false; } else { if (Math.random() < 0.03 && artist.skill < artist.potential) artist.skill++; } if (Math.random() < 0.08) artist.popularity = Math.max(1, Math.min(100, artist.popularity + (Math.random() > 0.6 ? 1 : -1))); }); }); if (gameState.week > 52 && gameState.week % 52 === 0 && Math.random() < NEW_AI_LABEL_CHANCE_PER_YEAR) { const newAiLabelName = generateAiLabelName(); const newAiLabel = { id: `ai-label-${gameState.aiLabelIdCounter++}`, name: newAiLabelName, artists: [], money: 50000 + Math.floor(Math.random() * 50000), reputation: 5 + Math.floor(Math.random() * 15), nextActionAttemptWeek: gameState.week + 1, }; for (let j = 0; j < ARTISTS_FOR_NEW_AI_LABEL; j++) { newAiLabel.artists.push(generateArtist(true, newAiLabel.name)); } gameState.aiLabels.push(newAiLabel); updateMessage(`A new competitor, ${newAiLabelName}, has entered the scene!`, false); } gameState.money -= (totalWeeklyExpenses - trainingCosts); updateCharts(); let expenseMessage = `Expenses $${(totalWeeklyExpenses - trainingCosts).toLocaleString()}.`; if (trainingCosts > 0) { expenseMessage += ` Training $${trainingCosts.toLocaleString()}.`; } updateMessage(`Week ${gameState.week}: ${expenseMessage}`); if (gameState.money < 0 && gameState.artists.length > 0) { gameOver(`Bankrupt! Game Over.`); } else if (gameState.money < -50000) { gameOver(`Deeply Bankrupt! Game Over.`); } else if (gameState.money >= 1000000 && gameState.reputation >= 100 && gameState.artists.length >= 3) { gameOver(`🏆 Music Mogul! Money: $${gameState.money.toLocaleString()}, Rep: ${gameState.reputation}. YOU WIN!`); } updateUI(); }
        function gameOver(message) { if (!gameState) return; gameState.gameOver = true; updateMessage(`--- GAME OVER --- ${message}`, true); const nextWeekBtn = document.getElementById('next-week-btn'); if (nextWeekBtn) { nextWeekBtn.disabled = true; nextWeekBtn.classList.add('btn-disabled'); } const saveBtn = document.getElementById('save-game-btn'); if(saveBtn) { saveBtn.disabled = true; saveBtn.classList.add('btn-disabled'); } document.querySelectorAll('.action-btn').forEach(btn => { btn.disabled = true; btn.classList.add('btn-disabled'); }); const modalConfirmBtn = document.getElementById('modal-confirm-btn'); if (modalConfirmBtn) { modalConfirmBtn.disabled = true; modalConfirmBtn.classList.add('btn-disabled'); } }
        function updateUI() { if (!gameState) { console.warn("Attempted UI update without gameState."); return; } document.getElementById('money').textContent = `$${gameState.money.toLocaleString()}`; document.getElementById('reputation').textContent = gameState.reputation; document.getElementById('week').textContent = gameState.week; document.getElementById('artist-count').textContent = gameState.artists.length; document.getElementById('label-name-display').textContent = gameState.labelName || "Your Label"; renderAvailableArtists(); renderSignedArtists(); renderSongChart(); renderAlbumChart(); const nextWeekBtn = document.getElementById('next-week-btn'); if (nextWeekBtn) { nextWeekBtn.disabled = gameState.gameOver; nextWeekBtn.classList.toggle('btn-disabled', gameState.gameOver); } const saveBtn = document.getElementById('save-game-btn'); if(saveBtn) { saveBtn.disabled = gameState.gameOver; saveBtn.classList.toggle('btn-disabled', gameState.gameOver); } }
        function renderAvailableArtists() { const container = document.getElementById('available-artists'); container.innerHTML = ''; if (!gameState || gameState.availableArtists.length === 0) { container.innerHTML = '<p class="text-gray-400 italic p-4 text-center">No new talent scouted.</p>'; return; } gameState.availableArtists.forEach(artist => { const card = document.createElement('div'); card.className = 'card'; card.innerHTML = `<h3 class="font-semibold text-lg text-indigo-300">${artist.name}</h3><p class="text-sm text-gray-400 mb-1">Genre: ${artist.genre}</p><div class="text-xs space-y-1 mb-2 text-gray-300" data-tooltip="Skill | Potential | Popularity"><span>S:${artist.skill}</span>|<span>P:${artist.potential}</span>|<span>Pop:${artist.popularity}</span></div><p class="text-sm font-medium text-yellow-400 mb-3">Asking Advance (Est.): ~$${(artist.desiredContract?.advance || artist.signingCost).toLocaleString()}</p><button class="btn btn-success action-btn w-full ${gameState.gameOver ? 'btn-disabled' : ''}" onclick="signArtist(${artist.id})" ${gameState.gameOver ? 'disabled' : ''}>Negotiate Contract</button>`; container.appendChild(card); }); }
        function renderSignedArtists() { const container = document.getElementById('signed-artists'); container.innerHTML = ''; if (!gameState || gameState.artists.length === 0) { container.innerHTML = '<p class="text-gray-400 italic p-4 text-center">No artists signed.</p>'; return; } gameState.artists.forEach(artist => { const card = document.createElement('div'); card.className = 'card'; const canTrain = artist.skill < artist.potential; const trainingCost = calculateTrainingCost(artist); let releaseDisabled = artist.isTraining || gameState.gameOver; let singleButtonTooltip = releaseDisabled ? (artist.isTraining ? "Artist is Training" : "Game Over") : "Plan a new single release"; let albumButtonTooltip = releaseDisabled ? (artist.isTraining ? "Artist is Training" : "Game Over") : "Plan a new album release"; const baseSingleCost = SINGLE_BASE_COST + Math.floor(artist.skill * 50); const baseAlbumCost = (SINGLE_BASE_COST + Math.floor(artist.skill * 50)) * ALBUM_BASE_COST_FACTOR + (artist.popularity * 100); let singlePlanDisabled = releaseDisabled; if (!singlePlanDisabled && gameState.money < baseSingleCost) { singlePlanDisabled = true; singleButtonTooltip = "Insufficient funds to plan single"; } const albumEligibleForButton = canArtistReleaseAlbum(artist, true) && !artist.isTraining; let albumPlanDisabled = releaseDisabled; if (!albumPlanDisabled && !albumEligibleForButton && !artist.isTraining ) { albumPlanDisabled = true; albumButtonTooltip = getAlbumEligibilityReason(artist, true); } if (!albumPlanDisabled && albumEligibleForButton && gameState.money < baseAlbumCost) { albumPlanDisabled = true; albumButtonTooltip = "Insufficient funds to plan album"; } let albumButtonHTML = ''; if (albumEligibleForButton) { albumButtonHTML = `<button class="btn btn-warning action-btn w-full mt-1 ${albumPlanDisabled ? 'btn-disabled' : ''}" onclick="openReleaseModal(${artist.id}, 'album')" ${albumPlanDisabled ? 'disabled' : ''} title="${albumButtonTooltip}">Plan Album</button>`; } else { albumButtonHTML = `<button class="btn btn-warning action-btn w-full mt-1 btn-disabled" disabled title="${albumButtonTooltip}">Plan Album</button>`; } let trainButtonHTML = ''; if (canTrain) { const btnText = artist.isTraining ? 'Stop Training' : `Train ($${trainingCost.toLocaleString()}/wk)`; const btnClass = artist.isTraining ? 'btn-danger' : 'btn-purple'; trainButtonHTML = `<button class="${btnClass} action-btn w-full mt-1 ${gameState.gameOver ? 'btn-disabled' : ''}" onclick="toggleTraining(${artist.id})" ${gameState.gameOver ? 'disabled' : ''}>${btnText}</button>`; } else { trainButtonHTML = `<button class="btn btn-purple action-btn w-full mt-1 btn-disabled" disabled title="Potential reached">Train</button>`; } let historyHTML = '<div class="release-history text-xs">'; const recentReleases = [...artist.songs, ...artist.albums].sort((a,b) => b.weekReleased - a.weekReleased).slice(0,3); if (recentReleases.length > 0) { historyHTML += '<p class="text-gray-500 mb-1 font-semibold">Recent:</p>'; recentReleases.forEach(r => { const type = r.id.startsWith('song-') ? 'S' : 'A'; historyHTML += `<div class="release-item" data-tooltip="Wk ${r.weekReleased}: ${r.name}"><span>${r.name.substring(0,15)}${r.name.length>15?'...':''} (${type})</span> <span>Q:${r.quality}/C:${r.criticalScore}</span></div>`; }); } else { historyHTML += '<p class="text-gray-500 italic">No releases.</p>'; } historyHTML += '</div>'; const moraleBarHTML = `<div class="text-xs text-gray-400 mt-1">Morale: ${artist.morale} ${artist.buzz > 0 ? `| Buzz: ${artist.buzz}` : ''}</div><div class="artist-mood-bar"><div class="artist-mood-fill" style="width: ${artist.morale}%; background-color: ${getMoraleColor(artist.morale)};"></div></div>`; card.innerHTML = `<h3 class="font-semibold text-lg text-emerald-300 flex justify-between items-center"><span>${artist.name}</span>${artist.isTraining ? '<span class="artist-status">[Training]</span>' : ''}</h3><p class="text-sm text-gray-400 mb-1">${artist.genre}</p><div class="text-xs space-y-1 mb-1 text-gray-300" data-tooltip="Skill | Potential | Popularity"><span>S:${artist.skill}</span>|<span>P:${artist.potential}</span>|<span>Pop:${artist.popularity}</span></div> ${moraleBarHTML} <p class="text-xs text-red-400 mb-1">Cost: $${artist.weeklyCost.toLocaleString()}/wk</p><p class="text-xs text-gray-500 mb-3" data-tooltip="Weeks since player released for this artist">Last Release: ${artist.weeksSinceLastReleaseByPlayer}w ago</p><div class="grid grid-cols-2 gap-2"><button class="btn btn-primary action-btn w-full ${singlePlanDisabled ? 'btn-disabled' : ''}" onclick="openReleaseModal(${artist.id}, 'single')" ${singlePlanDisabled ? 'disabled' : ''} title="${singleButtonTooltip}">Plan Single</button>${albumButtonHTML}${trainButtonHTML}<div></div></div>${historyHTML}`; container.appendChild(card); }); }
        function getMoraleColor(morale) { if (morale < 30) return '#ef4444'; if (morale < 60) return '#f59e0b'; return '#10b981'; }
        function renderSongChart() { const container = document.getElementById('song-chart'); container.innerHTML = ''; if (!gameState) { container.innerHTML = '<p class="text-gray-400 italic p-4 text-center">Loading chart...</p>'; return; } const topN = Math.min(gameState.chartingSongs.length, 10); if (topN === 0) { container.innerHTML = '<p class="text-gray-400 italic p-4 text-center">The singles chart is empty.</p>'; return; } for (let i = 0; i < topN; i++) { const song = gameState.chartingSongs[i]; const el = document.createElement('div'); el.className = 'chart-item'; const recordLabelDisplay = song.recordLabel ? `<span class="chart-label">(${song.recordLabel})</span>` : ''; el.innerHTML = `<span class="chart-rank">#${i + 1}</span><div class="chart-details"><div class="chart-title" title="${song.songName}">${song.songName}</div><div class="chart-artist">${song.artistName} ${recordLabelDisplay}</div></div><div class="chart-stats" data-tooltip="Score/Weeks/Quality/Critics"><div>${song.currentChartScore}/${song.weeksOnChart}w</div><div class="text-xs text-cyan-400">Q:${song.quality} C:${song.criticalScore}</div></div>`; container.appendChild(el); } }
        function renderAlbumChart() { const container = document.getElementById('album-chart'); container.innerHTML = ''; if (!gameState) { container.innerHTML = '<p class="text-gray-400 italic p-4 text-center">Loading chart...</p>'; return; } const topN = Math.min(gameState.chartingAlbums.length, 7); if (topN === 0) { container.innerHTML = '<p class="text-gray-400 italic p-4 text-center">The album chart is empty.</p>'; return; } for (let i = 0; i < topN; i++) { const album = gameState.chartingAlbums[i]; const el = document.createElement('div'); el.className = 'chart-item'; const recordLabelDisplay = album.recordLabel ? `<span class="chart-label">(${album.recordLabel})</span>` : ''; el.innerHTML = `<span class="chart-rank">#${i + 1}</span><div class="chart-details"><div class="chart-title" title="${album.albumName}">${album.albumName}</div><div class="chart-artist">${album.artistName} ${recordLabelDisplay}</div></div><div class="chart-stats" data-tooltip="Score/Weeks/Quality/Critics"><div>${album.currentChartScore}/${album.weeksOnChart}w</div><div class="text-xs text-cyan-400">Q:${album.quality} C:${album.criticalScore}</div></div>`; container.appendChild(el); } }
        function updateMessage(newMessage, isError = false) { const messageBox = document.getElementById('message-box'); if (!messageBox && gameState) { console.log(`Message (${isError ? 'Error' : 'Info'}): ${newMessage}`); return; } else if (!messageBox) return; if(gameState) gameState.message = newMessage; messageBox.textContent = newMessage; messageBox.className = `mb-6 p-3 rounded-md text-center font-medium transition-all duration-300 ${isError ? 'bg-red-800 text-red-100 shadow-lg border border-red-600' : 'bg-blue-800 text-blue-100 shadow-lg border border-blue-600'}`; }

        // --- Utility Functions ---
        function capitalizeFirstLetter(string) { return string.charAt(0).toUpperCase() + string.slice(1); }
        function getMarketingLevelName(level) { return ["None", "Basic", "Standard", "Major"][level] || "Unknown"; }

        // --- View Switching Logic ---
        function switchView(viewId) { console.log("Switching view to:", viewId); document.getElementById('label-view').classList.add('hidden'); document.getElementById('artists-view-container').classList.add('hidden'); document.querySelectorAll('.main-nav .btn-nav').forEach(btn => btn.classList.remove('active')); const targetView = document.getElementById(viewId); if (targetView) { targetView.classList.remove('hidden'); const targetButton = document.querySelector(`.main-nav .btn-nav[data-view="${viewId}"]`); if (targetButton) targetButton.classList.add('active'); else console.warn("Target nav button not found for view:", viewId); if (viewId === 'artists-view-container') { populateGlobalArtistView(); } } else { console.error("Target view not found for ID:", viewId); } }
        function populateGlobalArtistView() { if (!gameState) return; const listContainer = document.getElementById('global-artist-list'); listContainer.innerHTML = ''; const statusFilter = document.getElementById('filter-artist-status').value; const genreFilter = document.getElementById('filter-artist-genre').value; let allArtistsInWorld = []; gameState.artists.forEach(a => allArtistsInWorld.push({...a, status: 'player_signed'})); gameState.aiLabels.forEach(label => { label.artists.forEach(a => allArtistsInWorld.push({...a, status: 'ai_signed'})); }); gameState.availableArtists.forEach(a => allArtistsInWorld.push({...a, status: 'unsigned_available'})); gameState.globalUnsignedArtists.forEach(a => allArtistsInWorld.push({...a, status: 'unsigned_global'})); const uniqueArtistIds = new Set(); const uniqueArtists = allArtistsInWorld.filter(artist => { if (uniqueArtistIds.has(artist.id)) { return false; } uniqueArtistIds.add(artist.id); return true; }); const filteredArtists = uniqueArtists.filter(artist => { let statusMatch = false; if (statusFilter === 'all') statusMatch = true; else if (statusFilter === 'player' && artist.status === 'player_signed') statusMatch = true; else if (statusFilter === 'ai_signed' && artist.status === 'ai_signed') statusMatch = true; else if (statusFilter === 'unsigned' && (artist.status === 'unsigned_available' || artist.status === 'unsigned_global')) statusMatch = true; const genreMatch = genreFilter === 'all' || artist.genre === genreFilter; return statusMatch && genreMatch; }); if (filteredArtists.length === 0) { listContainer.innerHTML = '<p class="text-gray-400 italic p-4 text-center">No artists match your filters.</p>'; return; } filteredArtists.sort((a, b) => b.popularity - a.popularity); filteredArtists.forEach(artist => { const card = document.createElement('div'); card.className = 'card global-artist-card'; let labelDisplay = artist.recordLabel; if (artist.status === 'unsigned_available' || artist.status === 'unsigned_global') { labelDisplay = "Unsigned"; } card.innerHTML = ` <h3 class="font-semibold text-lg text-purple-300">${artist.name}</h3> <p class="text-sm text-gray-400 mb-1">Genre: ${artist.genre}</p> <p class="artist-label mb-1">Label: ${labelDisplay}</p> <div class="text-xs space-y-1 mb-2 text-gray-300"> <span>Skill: ${artist.skill}</span> | <span>Potential: ${artist.potential}</span> | <span>Popularity: ${artist.popularity}</span> </div> ${artist.status === 'player_signed' ? `<div class="text-xs text-gray-400">Morale: ${artist.morale} | Buzz: ${artist.buzz}</div>` : ''} ${(artist.status === 'unsigned_available' || artist.status === 'unsigned_global') && !artist.signed && !gameState.gameOver ? `<button class="btn btn-success btn-sm w-full mt-2 action-btn" onclick="signArtist('${artist.id}')">Negotiate</button>` : ''} `; listContainer.appendChild(card); }); }
        function populateGenreFilter() { const genreFilterSelect = document.getElementById('filter-artist-genre'); genreFilterSelect.innerHTML = '<option value="all">All Genres</option>'; GENRES.forEach(genre => { const option = document.createElement('option'); option.value = genre; option.textContent = genre; genreFilterSelect.appendChild(option); }); }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => { console.log("DOMContentLoaded event fired."); const newGameBtn = document.getElementById('new-game-btn'); const loadGameBtn = document.getElementById('load-game-btn'); const navLabelViewBtn = document.getElementById('nav-label-view-btn'); const navArtistsViewBtn = document.getElementById('nav-artists-view-btn'); const filterStatus = document.getElementById('filter-artist-status'); const filterGenre = document.getElementById('filter-artist-genre'); if (newGameBtn) { newGameBtn.addEventListener('click', initNewGame); console.log("Listener for new-game-btn ADDED."); } else { console.error("new-game-btn not found!"); } if (loadGameBtn) { loadGameBtn.addEventListener('click', loadGame); console.log("Listener for load-game-btn ADDED."); if (!localStorage.getItem(SAVE_KEY)) { loadGameBtn.classList.add('btn-disabled'); loadGameBtn.disabled = true; loadGameBtn.title = "No saved game found"; } } else { console.error("load-game-btn not found!"); } if(navLabelViewBtn) navLabelViewBtn.addEventListener('click', () => switchView('label-view')); else console.error("nav-label-view-btn not found"); if(navArtistsViewBtn) navArtistsViewBtn.addEventListener('click', () => switchView('artists-view-container')); else console.error("nav-artists-view-btn not found"); if(filterStatus) filterStatus.addEventListener('change', populateGlobalArtistView); if(filterGenre) filterGenre.addEventListener('change', populateGlobalArtistView); populateGenreFilter(); document.getElementById('next-week-btn').addEventListener('click', () => { if(gameState && !gameState.gameOver) nextWeek(); }); document.getElementById('save-game-btn').addEventListener('click', () => { if(gameState && !gameState.gameOver) saveGame(); }); document.getElementById('marketing-level').addEventListener('change', () => { if(gameState) updateTotalCost(); }); document.getElementById('release-format-select').addEventListener('change', () => { if(gameState) updateTotalCost(); }); document.getElementById('modal-cancel-btn').addEventListener('click', closeReleaseModal); document.getElementById('modal-confirm-btn').addEventListener('click', () => { if(gameState) confirmRelease(); }); setupContractNegotiationListeners(); console.log("All event listeners setup attempt complete."); });
    </script>

</body>
</html>
